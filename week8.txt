운영체제 달라도 같은 하드웨어 소켓 API를 사용하면 통신 가능
소켓 통신 절차와 API
socket() 생성, 서버가 bind(), listen() 실행, client가 connect()로 연결요청
서버가 accept로 연결 받음, Send()로 통신 전송, Receive()로 전송 받음
client가 close()로 종료 요청, 서버가 read()로 요청 받음, 서버가 close()로 종료
다시 불러올 시엔 서버가 꺼진게 아니면 서버가 accept()로 돌아가서 연결

Socket class >> SetSocketOption method, SocketOptionLevel(옵션 적용 범위, IP, Socket, TCP, UDP)
SocketOptionName(옵션 적용 지정, Broadcast, HopLimit, KeepAlive, KeepAliveCount, Multicast, BufferSize, TimeOut)
SocketFlags

네트워크에서 자주 사용되는 클래스 >> Array(전체를 복사할 때), BitConverter(데이터 전송시 변수 타입을 바이트로 변경), Encoding(string사용할때)
Unicode(한번 해봐라, 복잡하다, 그래도 해보면 좋다, 아스키 코드는 한글에 문제가 생길 수 있으니 해봐라)

Buffer와 TCP/IP protocol
Socket Buffer(버퍼 사이즈 변경, 패킷 전송 처리 차이)
Data latency >> UDP는 1500바이트를 보통 한번에 던짐 = 쪼개서 받지 못함, TCP는 한번에 보내도 쪼개서 받을 수 있다
User Buffer (프로토콜 사용시 차이, UDP,TCP 최소 최대 사이즈, 지연 처리 및 결합, 송수신 데이터 처리)
//다중 접속(멀티 프로세서, 멀티 쓰레드, 멀티 플렉싱, 비동기 연결)
UDP 최소, 최대 사이즈는 최대 사이즈가 1500으로 되어있으며 지정된 사이즈를 넘길 경우 예외 발생
지연 처리 및 결합은 전송 시간의 차이가 중요하며 Recv 함수의 호출 시간도 포함되어 있다
소켓 옵션은 optval = (int)socket.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, optavl)으로 사용한다
//소켓 버퍼를 줄여서 한번에 적은 양의 버퍼를 받고 지연 시간을 길게 잡아 아주 조금씩 계속 받을 수 있게 해봤다
//유저 버퍼를 늘리고 소켓 버퍼를 줄이면 비대한 유저 버퍼를 채우기 위해 조금씩 매우 빠르게 들어온다
//유저 버퍼는 65536이 기본, 소켓 버퍼은 1500이 기본
//소켓 버퍼 사이즈를 조절해 테스트 해봄
//버퍼 사이즈 만큼 MTU(Maximum Transmission Unit, 네트워크에 연결된 장치가 받아들일 수 있는 최대 패킷 크기) 사이즈를 변경
Protocol
송수신 데이터 처리
-데이터 시작, 끝
-데이터 크기
-데이터 지연, 결합
-토큰 분리 >> 파싱
-의미 있는 구문으로 분석
메세지 형식
-고정식(정해진 크기만큼 보내고 빈 공간을 의미 없는 문자로 채운다), 구현 쉽고 확장성 딸림
-가변식(보낼 양을 데이터 앞에 알리고 데이터 수신), 버퍼 용량 부담이 적고 확장성이 높음
-가변식2(정해진 문자나 단어를 사용해 데이터의 끝을 표시하는 방법, 메세지 중간에 해당 문자나 단어가 들어가면 중간에 짤리기 때문에 조심)
-고정+가변식
-확장 >> 헤더 + 데이터
단순한 패킷 툴 이상으로 (보낼 용량 제한, 개행문자를 기준으로 지정, 데이터 크기 선 입력)
//수신 버퍼 사이즈 설정, 수신 딜레이 설정, 함수 실행시 모든 데이터를 받지 못할 수 있다
//루프를 걸어서 데이터 수신, 받을 데이터의 크기를 잡고 루프를 탈출하기 위해 if로 데이터 사이즈 제한, 탈출 or 시간 제한을 걸어 탈출
//아무리 많이 잡아도 한번에 수신할 수 있는 데이터는 보내는 사람 마음이다
//socket.Recive에서 2번 인자를 0으로 하면 계속 덮어 씌워지므로 데이터 합을 집어 넣는다
//데이터가 오기까지 시간이 걸리니 그동안 다른것을 할지 생각
//

요청과 응답 설계
에러 처리 설계
데이터 양과 속도 감안